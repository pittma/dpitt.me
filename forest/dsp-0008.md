---
title: "The Hauntology of Functional Programming"
publish: true
track: true
tags: self, programming, philosophy
---

Jacques Derrida coined the term hauntology in his book _Specters of
Marx_. The term was birthed in a discussion of the notion that the
fall of the Soviet Union meant the death of communism. Derrida posited
however, that, "if communism has always been spectral, what does it
mean to say that it is now dead?" Derrida's case was that the
post-marxist, capitalist world would forever be haunted by Marx's
wraith.

His point was that it is irrelevant whether capitalism "won" with the
fall of the Soviet Union, because we as human beings can no longer
exist without knowing the possibilities of Marxism.  This idea can be
abstracted into a more general case, expressed as "always-already".
Always-already encompasses the phenomenon wherein one cannot "unknow"
a concept, that the knowing of such a concept demarcates a diametrical
_before_ and _after_ which will never exist contemporaneously. It's a
punctuation in existence.  Think of a favorite book which you compare
all books to: Going back to a time before you read this book is
impossible, you even compare books you read _before_ this one to this
book.  It becomes a scale on which you measure every literary
encounter and is heretofore deeply entangled in your
existence--there's no going back.

Over the course of the last year, I've dipped my toes in the Haskell
pool while simultaneously exploring its algebraic roots in type and
category theory. It was the latest stop in my what I thought was an
interminable mission of curiosity.  This trek's penultimate stop was
an interest in compilers, which undoubtably paved the way to this
mathematical interest. I met with a compiler team at work and
expressed an interest in their work, and mentioned my studies: I'd
been given a book which was touted as the canonical text in learning
about compilers, which, of course, they told me was utterly
irrelevant. But the truth was and is, that "working on compilers" is
not what I was looking for; it was instead a misguided foray into
something much more general.

Fast-forward to a few months later, I'm sitting in an interview and
having an impassioned discussion about a futile attempt to formalize
something at work using Haskell's [`Arrow`
typeclass](https://www.haskell.org/arrows/), and how, frankly, hard it
was to even get its requisites in order, namely,
[`Category`](https://www.haskell.org/arrows/).

During the interview, my interviewer said to me (a paraphrasing), "I
was like you. That's how I ended up here: I was on a constant search
for _rigor_."

My head spun. He'd cut down to the brass tacks of my own milieu and
had a line of sight to a destination which hadn't yet come into my
view. I've been haunted by the specter of rigor without knowing its
name.
